<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>cka prep</title>
    <style>
        body {
            font-family: "SF Pro Display", system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";
            max-width: 480px;
            margin: 0 auto;
            font-size: 13px;
        }
        pre {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<hr>
<h1>~ cka prep</h1>
<hr>
<h2>Exam Details</h2>

<ul>
    <li>
        25% Cluster Arch, Installation and Configuration
        <ul>
            <li>
                Demonstrate the process of installing a cluster from scratch,
                upgrading a cluster version, and backing up restoring etcd
                database.
            </li>
        <li>
            Also RBAC
        </li>
        </ul>
    </li>
    <li>
        15% Workloads and Scheduling
        <ul>
        <li>
            Understand the effect of Pod resource limits on scheduling.
        </li>
        </ul>
    </li>
    <li>
        20% Services and Networking
        <ul>
        <li>
            Knowledge of Service and Ingress.
        </li>
        </ul>
    </li>
    <li>
        10% Storage
        <ul>
        <li>
            Volumes
        </li>
        </ul>
    </li>
    <li>
        30% Troubleshooting
        <ul>
        <li>
            Confronted with typical scenarios that you need to fix.
        </li>
        </ul>
    </li>
</ul>
<p>
It is essential that you become one with <i>`kubectl`</i>, <i>`kubeadm`</i>, and
<i>`etcdctl`</i>
</p>

<p>
When killing objects you may want to not wait for it to be shut down
gracefully, you can use <i>`--force`</i> to kill the object.
</p>

<h2> Cluster Architecture, Installation and Configuration </h2>

<p>
Typical tasks you would expect a k8s admin to know, understanding the
architectural components, setting up a cluster from scratch, and maintaining a
cluster going forward
</p>

<h3 >Role-Based Access Control (RBAC) </h3>

<p>
To control who can access what on the cluster we need to establish certain
policies
</p>

<p>
RBAC defines policies for users, groups and processes, by letting them (or
disallowing them) to manage certain API resources.
</p>

<p>
RBAC has 3 building blocks:
</p>
<ul>
    <li>
        <b>Subject</b>
        <ul>
            <li>
                The user or process that want to access a resource
            </li>
            <li>
                E.g. Group, Users, SA (Service Accounts)
            </li>
        </ul>
    </li>
    <li>
        <b>Resource</b>
        <ul>
            <li>
                The k8s API object
            </li>
            <li>
                E.g. pods, deployments, services, etc..
            </li>
        </ul>
    </li>
    <li>
        <b>Verb</b>
        <ul>
            <li>
                The operation that can be executed on the resource.
            </li>
            <li>
                E.g. create, list, watch
            </li>
        </ul>
    </li>
</ul>



<h3> Creating a Subject </h3>

<p>
    Users and groups are not stored in <i>`etcd`</i> (the k8s db), they are
    meant for processes running outside of the cluster. On the other hand,
    service accounts are k8s objects and are used by processes running inside
    of the cluster.
</p>


<h4> User accounts and groups</h4>

<p>
    As stated before there is no k8s object for user, instead the job of
    creating the credential and distributing to the users is done externally by
    the admin.
</p>

<p>
    There are different ways k8s can authenticate a user:
</p>


<ul>
    <li>
        <b>X.508 client certificate</b>
        <ul>
            <li>Uses OpenSSL cert</li>
        </ul>
    </li>
    <li>
        <b>Basic Auth</b>
        <ul>
            <li>Uses username and password</li>
        </ul>
    </li>
    <li>
        <b>Bearer tokens</b>
        <ul>
            <li>Uses OpenID or webhooks as auth</li>
        </ul>
    </li>
</ul>

<p>
You wont have to create a user in the exam, but here are the steps for creating
one using the OpenSSL method.
</p>

<ol>
    <li>
        <p>
            Go to k8s control plane node and create a temporary dir that will
            have the keys.
        </p>
        <code>mkdir cert && cd cert</code>
    </li>
    <li>
        <p>Create a private key using <i>openssl</i> (username.key)</p>
        <code>openssl genrsa -out johndoe.key 2048</code>
    </li>
    <li>
        <p>Create a cerficiate sign request (a .csr file) with the key from the previous step</p>
        <code>
            openssl req -new -key johndoe.key -out johndoe.csr -subj
                "/CN=johndoe/O=cka-study-guide"
        </code>
    </li>
    <li>
        <p>Sign the .csr with the k8s CA (it usually is under <i>/etc/kubernetes/pki</i>)</p>
        <code>
            openssl x509 -req -in johndoe.csr -CA ca.crt -CAkey ca.key
            -CAcreateserial -out johndoe.crt -days 364
        </code>
    </li>
    <li>
        <p>Add it to your kubeconfig file</p>
        <code>
            kubectl config set-credentials johndoe
            --client-certificate=johndoe.crt --client-key=johndoe.key
        </code>
    </li>
</ol>

<h4> ServiceAccount </h4>

<p>
The users we created in the last paragraphs are meant to be used by humans, if
a pod or a <i>svc</i> needs to authenticate against the k8s cluster we need to
create a service account.
</p>

<p>
A k8s cluster already comes with a <i>`sa`</i> called default. Any pod that
does not explicitly assign a service account uses the default service account
</p>

<p>
It is super simple to create one with the imperative approach
</p>
<p>
<code>
$ k create sa build-bot
</code>
</p>

<p>
When creating a service account a secret holding the API token will be created
too. The Secret and token names use the Service Account name as a prefix.
</p>

<p>
To assing a service account to a pod you can do it imperatively by:
</p>
<code>
$ k run build-observer --image=alpine --restart=Never --serviceaccount=build-bot
</code>
</p>
<p>
Or add it to the manifest under <i>`spec.serviceAccountName`</i>.
</p>

<h3> Roles and RoleBindings </h3>

<p>
We have these two primitives:
</p>

<ul>
    <li>
        <b>Role</b>
        <p>Declares the api resources, and their operations. E.g. <i>Allow listing and deleting pods</i></p>
    </li>
    <li>
        <b>RoleBinding</b>
        <p>Connects or binds the roles to a <i>Subject</i></p>
    </li>
</ul>


<p>
There are some default roles:
</p>
<ul>
    <li>
        <b>cluster-admin</b>
        <p>rw access to resources across all namespaces</p>
    </li>
    <li>
        <b>admin</b>
        <p>
            rw access to resources in namespaces including roles and
            rolebinding
        </p>
    </li>
    <li>
        <b>edit</b>
        <p>
            rw access to resources in namespace except roles and rolebindings.
        </p>
    </li>
    <li>
        <b>view</b>
        <p>
            ro access to resources in namespace except roles, rolebindings and
            secrets.
        </p>
    </li>
</ul>

<h4>Creating Roles and RoleBindings</h4>

<p>
Imperative mode for roles.
</p>

<code>
k create role read-only --verb=list,get,watch --resource=pods,deployments,services
</code>

<p>
There is also <i>`--resource-name`</i> as a flag, where you can specify names
of pods.
</p>


<p>
Imperative mode for rolebindings.
</p>

<code>
$ k create rolebinding read-only-binding --role=read-only --user=johndoe
</code>

<p>
If then you do a <i>`get`</i> you wont see the subject, you need to render the
details to see that.
</p>

<p>
You can of course use <i>`describe`</i> and so on to check each of the
primitives once created, but there is also this little neat command: <i>$ k
auth can-i</i> this will give specific info on user permissions </p>

<p>
<code>
$ kubectl auth can-i --list --as johndoe
</code>
</p>
<p>
<code>
$ kubectl auth can-i list pods --as johndoe
</code>
</p>
<p>
<code>
Yes
</code>
</p>

<h3>Cluster Role</h3>

<p>
    Roles and RoleBinding are namespace specific. If we want to define the same
    but for the whole cluster we need to use <i>ClusterRole</i> and
    <i>ClusterRoleBinding</i>. The configuration elements are the same.
</p>

<h3>Aggregating RBAC Rules</h3>

<p>
Finally, we can aggregate different roles with label selection. Say you have
one role that lets you list pods, and other that lets you delete pods.
</p>

<p>
You can aggregate them with an <i>`aggregationRule`</i>
</p>

<p>
Here is an example from <b>Benjamin Muschko's Oreilly's Certified Kubernetes
Administrator (CKA) Study Guide.</b>
</p>

<p>
  YAML manifest for listing pods
</p>
<pre>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: list-pods
  namespace: rbac-example
  labels:
    rbac-pod-list: "true"
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - list
</pre>

<p>
  YAML manifest for deleting svc's
</p>
<pre>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: delete-services
  namespace: rbac-example
  labels:
    rbac-service-delete: "true"
rules:
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - delete
</pre>

<p>
  YAML manifest aggregating them.
</p>
<pre>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: pods-services-aggregation-rules
  namespace: rbac-example
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac-pod-list: "true"
  - matchLabels:
      rbac-service-delete: "true"
rules: []
</pre>


</body>
</html>


