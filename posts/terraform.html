<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>terraform</title>
    <style>
        body {
            font-family: "SF Pro Display", system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";
            max-width: 480px;
            margin: 0 auto;
            font-size: 13px;
        }
        pre {
            border: 1px solid black;
            overflow-x: auto;
        }
        h2 > a {
            color: black;
            text-decoration: none;
        }
        h2 > a:hover {
            text-decoration: underline;
        }
        h2 > a:visited {
            color: black;
        }

        a:visited {
            color: blue;
        }

        .important {
            background-color: lightgray;
            padding: 1em
        }

        .chapter {
            font-style: italic;

        }
    </style>
</head>
<body>
<hr>
<p class='important'>
notes on ðŸ“– oreilly's book: <i>Terraform: Up and Running, 3rd Edition By
Yevgeniy Brikman</i>
</p>
<h1 id='top'>~ terraform</h1>
<a href='#table'>table of contents</a>
<h2 id='why'>why terraform?</h2>
<p>
First, let me state that it is better to manage a big fleet of servers using
code, you can have version control, which honestly seems to be reason enough to
consider it.
</p>

<p>
Before things like terraform, developers worked with operation teams, to deploy
their code.  This usually was in baremetal systems, where sysadmins had to take
care of installing dependencies, updating packages, deploying software, making
sure all the servers had the same (similarish) configurations, among other
stuff.
</p>

<p>
This caused a lot of issues, since things can get messy real quickly.
Therefore, developers came with the solution, of configuring, deploying and
doing pretty much everything with code. This can be done multiple ways, here I
list a few.
</p>
<ul>
  <li>
    <p>ad hoc scripts</p>
    <ul>
      <li>
        You write scripts in your favorite scripting language to install
        programs, update stuff and so on.
      </li>
      <li>
        Better than doing it on the fly, but, still have some issues, for
        example is hard to be consistent on all your scripts,  when multiple
        developers will be working on them.
      </li>
    </ul>
  </li>
  <li>
    <p>configuration management tools</p>
    <ul>
      <li>
        Stuff like <i>`ansible`</i>, tools that are designed to manage software
        on existing servers.
      </li>
      <li>
        Improvement compared with the ad hoc scripts, since this will be way
        more consistent, not only on your project but on multiple projects on
        different organizations.
      </li>
      <li>
        Other thing that make them a bit better than the ad hoc scripts, is
        that you can manage multiple heards of servers this way. With the ad
        hoc scripts you usually need to ssh to the system and run it or do
        something similar, with ansible you can deploy software in multiple
        servers with one command.
      </li>
    </ul>
  </li>
  <li>
    <p>server templating tools</p>
    <ul>
      <li>
        Instead of launching a bunch of servers and deploying the software with
        the same script on each. You build an image, and create the servers
        with this image.
      </li>
      <li>
        If you need to update some package or something, you rebuild the image,
        destroy the running server and redeploy.
      </li>
    </ul>
  </li>
  <li>
    <p>provisioning tools</p>
    <ul>
      <li>
        Here is where <b>terraform</b> comes into the picture. These tools will
        literally create servers themselves.
      </li>
      <li>
        Wait, how would they do that? Are they humans that go to a lab and
        mount a server with their hands? No, they will talk with cloud
        providers APIs and create the resources you need.
      </li>
      <li>
        The neat part about this is that like k8s, they use the declarative
        approach. You declare the status of your infra, and it will create it
        like you have define it. If you have a terraform file that says we need
        to create 10  servers with certain image, and further down the line you
        want to add 5 more. You can change that file to say 15, and terraform
        will take care of just having 15 servers, not 25.
      </li>
      <li>
        Other cool stuff, is version control. You can have this configuration
        files pass through a code review process.
      </li>
    </ul>
  </li>
</ul>
<p>
So why terraform among other tools? Well, the author of the book presents some
good points.
</p>
</p>
<ul>
  <li>
    <p>Domain Specific Language</p>
    <ul>
      <li>
        For starters they have a Domain Specific Language. Meaning there is
        this HCL language that you will find in all the terraform config files.
        This is can be beneficial, since some tools use general languages like
        python meaning you lose consistency from project to project.
      </li>
    </ul>
  </li>
  <li>
    <p>Masterless</p>
    <ul>
      <li>
        Do not need a server to keep track of the state, since the <i>"master
        server"</i> is the Cloud Provider itself.
      </li>
    </ul>
  </li>
</ul>
<p>
The author make some other points, but this two are enough for me I guess.
</p>

<h2 id='using'>using terraform</h2>

<p>
In the book they use aws, so we will use it here too. Knowledge is somewhat
transferable to your cloud provider of choice, the thing is that different
cloud providers, name stuff different, and also have different types of
resources. For example, <a
href='https://www.digitalocean.com/products/droplets'>digitalocean's
droplet</a> seem to be <a href='https://aws.amazon.com/ec2/features/'>aws
ec2</a>.
</p>

<p>
This means that names will change and so on. So if you are using something
different to aws, this notes might help, but you will have to refer to some
specific declarations for your specific cloud provider.
</p>

<p>
So create an account, give your credit card info to jeff bezos, and lets start.
</p>

<p>
The account you just created is the root account for your aws, so you can do
anything with it. It makes sense to create another one with less privilege for
doing what we want in the book.
</p>

<p>
You manage your accounts on the IAM (Identity and Access Management) panel.
Create one and give it AdministratorAccess. Create a Access Key ID and a Secret
Access Key. Store them somewhere safe, and export the variables in your shell.
<pre>
$ export AWS_ACCESS_KEY_ID=(your access key id)
$ export AWS_SECRET_ACCESS_KEY=(your secret access key)
</pre>
</p>

<p>
One quick note, we will use the Default VPC for the book. A VPC is an isolated
area of your AWS account that has its own virtual network and ip address space.
</p>
<p>
Once you exported the <i>`env`</i> variables and installed terraform we can
continue to create our first tf file.
</p>
<h3>Deploying a Single Server</h3>
<p>
You will create a <i>`.tf`</i> file. This is files are written in the DSL for
terraform called HCL (hashicorp configuration language). It is the declarative
language we talked about a bit before.
</p>
<p>
First thing we usually do is specify the provider, so you go to the dir were
you will have your project, and create a <i>`main.tf`</i> file with:
<pre>
provider "aws" {
  region = "us-east-2"
}
</pre>
</p>
<p>
We are telling terraform to use aws and that region.
</p>
<p>
Now, the syntax  will be pretty much the same for any provider, the thing that
will change is the types of resources you can create. Generally you will do
something like:
<pre>
resource "provider_resource" "name" {
    [config ...]
}
</pre>
</p>
<ul>
  <li>
    <p><b>provider</b>: this would be aws</p>
  </li>
  <li>
    <p>
      <b>resource</b>: this would the type of resource, in our case we will use
      <i>instance</i>, which is aws lingo for ec2 instance.
    </p>
  </li>
  <li>
    <p>
      <b>name</b>: identifier to use inside terraform. Will come handy when
      using expressions.
    </p>
  </li>
  <li>
    <p>
      <b>config</b>: resource specific config
    </p>
  </li>
</ul>

<p>
Okay so if we want to create a ec2 instance , with a specific ami (amazon
machine images) and with a name we will do something like:
<pre>
resource "aws_instance" "example" {
    # amazon machine image to run on the ec2 instance, this is an ubuntu 20.04
    ami = "ami-0fb653ca2d3203ac1"
    instance_type = "t2.micro"
    tags = {
        Name = "terraform-example"
    }
}
</pre>
</p>
<p>
We use <i>t2.micro</i>, which has one virtual CPU, 1 GB of memory, and is part
of the AWS Free Tier.
</p>

<p>
Okay now we have our file. How do we actually deploy this on aws? Well here are
some verbs.
</p>
<ul>
  <li>
    <p>
      <b>terraform init</b>: this will scan the code, check which
      providers we will be using and download the code for them. Everything is
      put in the <i>`.terraform`</i>.
    </p>
  </li>
  <li>
    <p>
      <b>terraform plan</b>: show you what terraform will do without actually
      do it. Similar to a git diff on the format.
    </p>
  </li>
  <li>
    <p>
      <b>terraform apply</b>: shows the plan and ask you to confirm it. If you
      type <i>yes</i> it will talk with the providers and actually create the
      stuff.
    </p>
  </li>
</ul>
<p>
Remember terraform already knows what resources have been created. So if we
update the resource, it will update the one we already created. Or if the
update needs to destroy and recreate it will do that too.
</p>
<p>
Last step, add this to your git repo. Here is a quick <i>`.gitignore`</i>
<pre>
.terraform
*.tfstate
*.tfstate.backup
</pre>
</p>
<h3>Deploying a web server</h3>
<p>
So usually you would build an image with <a
href='https://www.packer.io/'>packer</a> upload it to <i>ami</i> and tell the
resource to use that image. Since this is a quick example, we are going to use
a web server that comes already with ubuntu 20.04.
</p>
<p>
You have the option of passing shell scripts to on the user_data config
variable on the resource, so we will take advantage of this to tell our ubuntu
to start the web server.
<pre>
resource "aws_instance" "example" {
    # amazon machine image to run on the ec2 instance, this is an ubuntu 20.04
    ami = "ami-0fb653ca2d3203ac1"
    instance_type = "t2.micro"

    # we would usually create an AMI for this with a real web app, using rails
    # or smth, but this is just a simple example.
    user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p 8080 &
              EOF

    user_data_replace_on_change = true

    tags = {
        Name = "terraform-example"
    }
}
</pre>
</p>

<p>
On the user_data we are sending the commands to start the server. Also note the
<i>`user_data_replace_on_change`</i>. This tells terraform to destroy the
instance and start it again if user data changes. Which is the case, so if now
you run <i>terraform apply</i>, aws will show that the first resource was
terminated and that a new one started running.
</p>
<p>
<i>Ojito</i> (Spanish for pay attention), we are not going to be able to make
an http request to the server due to  aws not allowing any incoming or outgoing
traffic from an ec2 instance.
</p>
<p>
We need to create a new resource for this called <i>`security_group`</i>. So in
the same file we will add:
<pre>
resource "aws_security_group" "instance" {
    name = "terraform-example-instance"

    ingress {
        from_port = 8080
        to_port = 8080
        protocol = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
    }
}
</pre>
</p>
<p>
This basically tells aws to accept traffic on port 8080, but we need to tell
our ec2 instance to use this resource.
</p>
<p>
So terraform has expressions, which is anything that return a value, one type
is a <i>`reference`</i>, which allows you to access values from other parts of
the code. For example for the security group we just created we can call it
saying: <i>`aws_security_group.instance.id`</i>
</p>
<p>
They call this <b>resource attribute reference</b> the syntax is
<pre>
PROVIDER_TYPE.NAME.ATTRIBUTE
</pre>
</p>
<p>
So now we need to add in our ec2 resource
<pre>
vpc_security_group_ids = [aws_security_group.instance.id]
</pre>
</p>
<p>
Adding this we are creating an <i>`implicit dependency`</i> meaning the order
in which we create the stuff matters. You can render a graph for this using
<pre>
$ terraform graph | dot -Tsvg > output.svg
</pre>
</p>
<p>
You need to have <i>`graphviz`</i> installed though
</p>



<h3 id='table'>~ table of contents</h3>
<ul>
  <li><a href='#why'>why terraform?</a></li>
  <li><a href='#using'>using terraform</a></li>
</ul>

<p><a href='#top'>â†‘ go to the top</a></p>

</body>
</html>


